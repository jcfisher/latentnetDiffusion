% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ergmm_degroot.R
\name{ergmmDegroot}
\alias{ergmmDegroot}
\title{Calculates latent space diffusion using the degroot function}
\usage{
ergmmDegroot(ergmm, Y, draws = 5, simulate = FALSE, iterations = 5, ...)
}
\arguments{
\item{ergmm:}{the object to get the posterior from}

\item{draws:}{the number of the draws from the posterior to take}

\item{simulate:}{logical indictor of whether to use the predicted
probabilities or the posterior predictive distribution}

\item{iterations:}{the number of iterations to run the simulation}

\item{...:}{additional parameters passed to degroot (if simulate is FALSE)
or degrootList (if simulate is TRUE)}
}
\value{
A (draws) length list of the simulation output for each draw from the
posterior.
}
\description{
Calculates latent space diffusion using the degroot function
}
\details{
This function calculates latent space diffusion, as described in
Fisher (2015), for a given number of draws from the posterior distribution
of a latent space model.  If simulate is FALSE (the default), the function
uses predicted probabilities of a tie to simulate diffusion.  Otherwise, if
simulated is TRUE, the function simulates (iterations) networks drawn from
the first (draws) draws from the posterior predictive distribution, and then 
runs the diffusion process over those simulated networks.

More specifically, when simulate is FALSE, the function gets the predicted
probability from the first (draws) draws from the posterior distribution.
Holding each of those draws constant, it calculates the degroot function
(iterations) times on each draw, returning a list of the output of the 
degroot function on each draw

When simulate is TRUE, the function simulates (iterations) networks from each
of the first (draws) draws from the posterior, creating the posterior
predictive distribution.  Then, for each of the draws, the function runs
degrootList, meaning that it calculates the weighted averaging over the first
network, followed by the second network, and so on until (iterations) is
reached.  A list is returned.
}
